"use strict";(self.webpackChunkipc144=self.webpackChunkipc144||[]).push([[329],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6991:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return d},default:function(){return c}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={sidebar_position:4},l="Pointers, Arrays and Structs",p={unversionedId:"F-Refinements/pointers-arrays-and-structs",id:"F-Refinements/pointers-arrays-and-structs",isDocsHomePage:!1,title:"Pointers, Arrays and Structs",description:"Learning Outcomes",source:"@site/docs/F-Refinements/pointers-arrays-and-structs.md",sourceDirName:"F-Refinements",slug:"/F-Refinements/pointers-arrays-and-structs",permalink:"/F-Refinements/pointers-arrays-and-structs",editUrl:"https://github.com/Seneca-ICTOER/IPC144/tree/main/docs/F-Refinements/pointers-arrays-and-structs.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"courseNotesSidebar",previous:{title:"More Input and Output",permalink:"/F-Refinements/more-input-and-output"},next:{title:"Two-Dimensional Arrays",permalink:"/F-Refinements/two-dimensional-arrays"}},d=[{value:"Learning Outcomes",id:"learning-outcomes",children:[],level:2},{value:"Introduction",id:"introduction",children:[],level:2},{value:"Review",id:"review",children:[{value:"Pointers",id:"pointers",children:[],level:3},{value:"Arrays",id:"arrays",children:[],level:3}],level:2},{value:"Equivalence",id:"equivalence",children:[{value:"Function Parameters",id:"function-parameters",children:[],level:3},{value:"Passing a Part of an Array",id:"passing-a-part-of-an-array",children:[],level:3},{value:"Pointer Arithmetic (Optional)",id:"pointer-arithmetic-optional",children:[],level:3}],level:2},{value:"Array of Structures",id:"array-of-structures",children:[{value:"Tabular Data",id:"tabular-data",children:[],level:3}],level:2},{value:"Composition",id:"composition",children:[],level:2},{value:"Member Access",id:"member-access",children:[],level:2},{value:"Variable-Length Arrays",id:"variable-length-arrays",children:[],level:2}],u={toc:d};function c(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"pointers-arrays-and-structs"},"Pointers, Arrays and Structs"),(0,i.kt)("h2",{id:"learning-outcomes"},"Learning Outcomes"),(0,i.kt)("p",null,"After reading this section, you will be able to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Connect procedures using pass-by-value and pass-by-address semantics to build a complete program"),(0,i.kt)("li",{parentName:"ul"},"Design data collections using arrays and structures to manage information efficiently")),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"A distinguishing feature of the C programming language is its direct access to primary memory.  The core language defines a separate pointer type for each primitive type and C compilers accept pointer types for each derived type.  This enables programmers to store the address of any type - primitive or derived - in a pointer variable.  The pointer types corresponding to the primitive types are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"char*"),(0,i.kt)("li",{parentName:"ul"},"int*"),(0,i.kt)("li",{parentName:"ul"},"float*"),(0,i.kt)("li",{parentName:"ul"},"double*")),(0,i.kt)("p",null,"The type of a pointer variable determines the number of bytes to interpret when converting into a data type the bit string in primary memory that starts at the specified address. "),(0,i.kt)("p",null,"Pointers and arrays are closely related in the C language.  The name of an array holds the address of the start of the array; that is, the name of the array is a pointer.  Since arrays by definition store element data contiguously in memory, we can access any array element using pointer syntax. "),(0,i.kt)("p",null,"This chapter examines this relationship between pointers, arrays and structures in more detail.  The chapter reviews pointer and array syntax and shows where syntax is interchangeable. "),(0,i.kt)("h2",{id:"review"},"Review"),(0,i.kt)("p",null,"We can model RAM as a linear map and use addresses on this map to identify bytes of information stored within memory.  For instance, in 512Mb of RAM, the address 0 identifies the first byte, the address 1 identifies the second byte and address 512Mb-1 identifies the last byte. "),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/memory%20map.png",alt:null})),(0,i.kt)("h3",{id:"pointers"},"Pointers"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Syntax")),(0,i.kt)("p",null,"A pointer is a variable that stores an address.  To allocate memory for a pointer that holds the address of a variable of type ",(0,i.kt)("inlineCode",{parentName:"p"},"double"),", we write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double *p;\n")),(0,i.kt)("p",null,"We say that ",(0,i.kt)("inlineCode",{parentName:"p"},"p")," ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"points"))," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"double"),".  We store the address of the ",(0,i.kt)("inlineCode",{parentName:"p"},"double")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"p")," as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double x = 456.7;\ndouble *p = &x;\n")),(0,i.kt)("p",null,"If the address is unknown, we initialize the pointer to ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double *p = NULL;\n// ...\ndouble x = 456.7;\np = &x;\n")),(0,i.kt)("p",null,"We can access data through a pointer once the pointer contains a valid address.  To access the data at the address pointed to, we ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"dereference"))," the pointer using the ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'double *p = NULL;\ndouble x = 456.7;\n\np = &x;\n\nprintf("Value stored in x %.1lf", *p); \n')),(0,i.kt)("p",null,"The above code snippet would produce the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Value stored in x 456.7 \n")),(0,i.kt)("h3",{id:"arrays"},"Arrays"),(0,i.kt)("p",null,"The C language stores the elements of an array contiguously in memory.  There is no empty space between adjacent elements and all elements share a common data type.  The name of the array holds the address of the start of the array.  We can determine the address of any element from the name of the array, the element's index and the array type. "),(0,i.kt)("p",null,"The index in array subscript notation refers to the offset into the array in terms of the number of elements; that is, the number of elements beyond the start of the array: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double a[10]; // 10 elements of type double = 80 bytes\nint i = 3;\n\na[i] = 5.4; // store 5.4 in memory location 3 x 8 bytes \n            // beyond the address of a  \n")),(0,i.kt)("p",null,"For example, if the address of ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"0x4e55a00"))," the address of ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i]")," is ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"0x4e55a18")),". "),(0,i.kt)("p",null,"We can store the address of an array in a separate pointer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double a[10];  // 10 elements of type double = 80 bytes\nint i = 3;\ndouble *p = a; // store address of a in p\np[i] = 5.4;    // store 5.4 in memory location 3 x 8 bytes \n               // beyond the address of a  \n")),(0,i.kt)("blockquote",null,(0,i.kt)("u",null,"Note"),(0,i.kt)("br",null),"`a` and `p` are interchangeable. `p` may also be used as an array!"),(0,i.kt)("h2",{id:"equivalence"},"Equivalence"),(0,i.kt)("h3",{id:"function-parameters"},"Function Parameters"),(0,i.kt)("p",null,"A function parameter that receives the ",(0,i.kt)("em",{parentName:"p"},"address of an array")," is a ",(0,i.kt)("strong",{parentName:"p"},"pointer"),".  In a function header, ",(0,i.kt)("em",{parentName:"p"},"array and pointer")," notations are ",(0,i.kt)("strong",{parentName:"p"},"equivalent"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"type identifier(type identifier[])\ntype identifier(type *identifier)\n")),(0,i.kt)("p",null,"For example, the syntax in the first function prototype is ",(0,i.kt)("strong",{parentName:"p"},"equivalent")," to the second function prototype:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void foo(int a[])  // These two function prototypes are\nvoid foo(int *b)   // equivalent and translate to the same thing!\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," from the second function prototype example above points to an array, it can be used to refer to specific array elements using standard array syntax: ",(0,i.kt)("inlineCode",{parentName:"p"},"b[i]"))),(0,i.kt)("h3",{id:"passing-a-part-of-an-array"},"Passing a Part of an Array"),(0,i.kt)("p",null,"To pass a part of an array to a function, we simply pass the address of the first element of that part:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Passing Part of an Array\n// pass_part.c\n\n#include <stdio.h>\n\nvoid display(int *a, int n);\n\nint main(void)\n{\n        int sku[] = { 2156, 4633, 3122, 5611};\n        const int n = 4;\n\n        display(&sku[1], n - 1);\n\n        return 0;\n}\n\nvoid display(int *a, int n)\n{\n        int i;\n\n        for (i = 0; i < n; i++)\n                printf("%5d\\n", a[i]);\n\n        printf("\\n");\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"4633\n3122\n5611\n")),(0,i.kt)("p",null,"Caution"),(0,i.kt)("p",null,"The syntactic equivalence between pointer parameters and array names does not extend to the definition of an array.  We cannot replace the definition of an array with a pointer definition.  An array definition allocates the stated number of memory locations for all of the elements in the array.  A pointer definition ",(0,i.kt)("strong",{parentName:"p"},"allocates only one memory location to hold a single address"),". "),(0,i.kt)("h3",{id:"pointer-arithmetic-optional"},"Pointer Arithmetic (Optional)"),(0,i.kt)("p",null,"Learning pointer arithmetic clarifies this equivalence between pointers an arrays.  We can obtain the address of an array element by multiplying the element's index by the number of bytes that each element occupies and add that product to the array's starting address.  Then, we can access the data at the resulting address simply by dereferencing that address. "),(0,i.kt)("p",null,"For example, the two examples below are equivalent:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Sample-1"),(0,i.kt)("th",{parentName:"tr",align:"left"}),(0,i.kt)("th",{parentName:"tr",align:"left"},"Sample-2"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"a[i]")),(0,i.kt)("td",{parentName:"tr",align:"left"},"is equivalent to"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"*(a + i)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"&a[i]")),(0,i.kt)("td",{parentName:"tr",align:"left"},"is equivalent to"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"(a + i)"))))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"a + i")," evaluates to the address of the ",(0,i.kt)("inlineCode",{parentName:"p"},"i+1-th")," element of ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," (",(0,i.kt)("inlineCode",{parentName:"p"},"&a[i]"),").  The rules for pointer arithmetic stipulate that we multiply the element's index by the size of an element before adding the array's starting address. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Examples")),(0,i.kt)("p",null,"We may replace array subscript notation with equivalent pointer notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int x;\nint a[] = {1, 2, 3};\n\nx = *a;      // stores 1 in x (the value of the first element)\nx = *(a + 1) // stores 2 in x (the value of the second element)\nx = *(a + 2) // stores 3 in x (the value of the third element)\n")),(0,i.kt)("p",null,"We can also use pointer addition to move from one element to the neighbouring element:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int a[3];\nint *p = a;\n\n*p = 1;      // stores 1 in a[0]\np++;         // increment the pointer to point to the next element in memory\n*p = 2;      // stores 2 in a[1]\np++;         // increment the pointer to point to the next element in memory\n*p = 3;      // stores 3 in a[2] \n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Caution"),(0,i.kt)("br",null),"\nAlthough a pointer can be incremented, ",(0,i.kt)("strong",{parentName:"p"},"an array name cannot"),".  This is because a pointer is a variable, while an array name is not a variable; that is, not a region of memory distinct from the array. ")),(0,i.kt)("h2",{id:"array-of-structures"},"Array of Structures"),(0,i.kt)("p",null,"We can define an array of objects of derived type just like we define an array of variables of primitive type.  We suffix the object identifier with a brackets-enclosed integer specifying the number of elements in the array.  This number is an integer constant or integer-constant expression. "),(0,i.kt)("p",null,"For example, to define an array of 40 ",(0,i.kt)("inlineCode",{parentName:"p"},"Student"),"s, we write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Student s[40];\n")),(0,i.kt)("p",null,"The subscripting rules for arrays apply equally to primitive types and structure types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"element indexing"))," is 0-based - the first element is ",(0,i.kt)("inlineCode",{parentName:"li"},"s[0]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"s[i]")," refers to the i+1-th element of the array"),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"name of the array alone"))," refers to the ",(0,i.kt)("strong",{parentName:"li"},"address")," of its first element - the address ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," is the ",(0,i.kt)("strong",{parentName:"li"},"same")," as the address ",(0,i.kt)("inlineCode",{parentName:"li"},"&s[0]"))),(0,i.kt)("h3",{id:"tabular-data"},"Tabular Data"),(0,i.kt)("p",null,"A structure type provides a convenient way of storing tabular data.  Each instance of the structure holds the information for one row in the table.  Each member of each instance holds one field of data in the row or record.  The array of objects holds the entire table."),(0,i.kt)("p",null,"Consider the following structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Student\n{\n        int id;         // student ID\n        float grade[4]; // grades\n        char name[31];  // student name\n};\n\nint main(void)\n{\n    // ...\n\n    struct Student s[40]; // table of 40 Student objects \n\n    // ...\n    return 0;\n}\n")),(0,i.kt)("p",null,"The student ID and name of the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"third student"))," would be accessed by ",(0,i.kt)("inlineCode",{parentName:"p"},"s[2].id")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"s[2].name")," respectively. "),(0,i.kt)("p",null,"To initialize the members of the first three elements of the table, we write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'struct Student s[40] = { {10001, 78.9f, 56.7f, 0f, 0f, "Harry"},\n                         {10002, 67.8f, 92.1f, 74.3f, 81.2f, "Jack"},\n                         {10003, 55.4f, 66.5f, 88.3f, 34.6f, "Chris"}   }; \n')),(0,i.kt)("p",null,"We arrange the initial values member by member for each object in turn.  The interior braces distinguish the values for one object from those for another object.  The interior braces are optional: we may list the values in the order in which they are stored in memory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'struct Student s[40] = { 10001, 78.9f, 56.7f, 0f, 0f, "Harry",\n                         10002, 67.8f, 92.1f, 74.3f, 81.2f, "Jack",\n                         10003, 55.4f, 66.5f, 88.3f, 34.6f, "Chris" }; \n')),(0,i.kt)("h2",{id:"composition"},"Composition"),(0,i.kt)("p",null,"A structure type may contain a member that is of another structure type.  The relationship between the types is called a ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"composition"))," relationship."),(0,i.kt)("p",null,"Consider a section of a course that contains a list of enrolled students: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Student\n{\n        int id;         // student ID\n        float grade[4]; // grades\n        char name[31];  // student name\n};\n\nstruct Section\n{\n        int studentCount;\n        struct Student students[40];\n};\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"IMPORTANT"),(0,i.kt)("br",null),"\nA structure ",(0,i.kt)("em",{parentName:"p"},"type")," may ",(0,i.kt)("strong",{parentName:"p"},"NOT")," contain an object of its ",(0,i.kt)("strong",{parentName:"p"},"own type")," (see below example).")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// A derrived type is not allowed to have its own type as a member!\nstruct Section\n{\n        int studentCount;\n        struct Section section;  // <==== !!!! ERROR !!!! \n};\n")),(0,i.kt)("h2",{id:"member-access"},"Member Access"),(0,i.kt)("p",null,"Dot, arrow, and subscript syntax extends to the members of structure types that are themselves structure types. "),(0,i.kt)("p",null,"For example, let us define a ",(0,i.kt)("inlineCode",{parentName:"p"},"Section")," object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Section abc123a;\n")),(0,i.kt)("p",null,"To set the number of students in ",(0,i.kt)("inlineCode",{parentName:"p"},"abc123a")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"23"),", we write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"abc123a.studentCount = 23; \n")),(0,i.kt)("p",null,"To set the student ID of the sixth student to ",(0,i.kt)("inlineCode",{parentName:"p"},"123456789"),", we write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"abc123a.students[5].id = 123456789;\n")),(0,i.kt)("p",null,"To set the third grade of the sixth student to a ",(0,i.kt)("inlineCode",{parentName:"p"},"67.8"),", we write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"abc123a.students[5].grade[2] = 67.8f;\n")),(0,i.kt)("p",null,"We say that ",(0,i.kt)("em",{parentName:"p"},"Section")," ",(0,i.kt)("inlineCode",{parentName:"p"},"abc123a")," has a ",(0,i.kt)("em",{parentName:"p"},"Student")," with student ID ",(0,i.kt)("inlineCode",{parentName:"p"},"123456789"),", whose third grade has been set to ",(0,i.kt)("inlineCode",{parentName:"p"},"67.8"),". "),(0,i.kt)("h2",{id:"variable-length-arrays"},"Variable-Length Arrays"),(0,i.kt)("p",null,"The size of an array can be defined at run-time; that is, the memory for the array can be allocated once its size is known.  Its size is a program variable.  We define the array only after its size is available.  The memory for the array is deallocated once we leave the block within which it has been allocated."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Variable-Length Array\n// var_len_array.c\n\n#include <stdio.h>\n\nvoid display(int g[], int n);\n\nint main(void)\n{\n        int i, n;\n\n        printf("Enter no of grades : "); \n        scanf("%d", &n);\n        int grade[n];    // Set array to size: n\n\n        for (i = 0; i < n; i++) \n        {\n                printf("Grade %d : ", i + 1); \n                scanf("%d", &grade[i]);\n        }\n\n        display(grade, n);\n\n        return 0;\n}\n\nvoid display(int g[], int n)\n{\n        int i;\n\n        for (i = 0; i < n; i++)\n                printf("%d ", g[i]);\n\n        printf("\\n");\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Enter no of grades : 3 \nGrade 1 : 9\nGrade 2 : 10\nGrade 3 : 7\n9 10 7\n")),(0,i.kt)("p",null,"The array is stored in the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"stack"))," segment of RAM ",(0,i.kt)("strong",{parentName:"p"},"alongside the local variables"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"!!! PORTABILITY ALERT !!!"),(0,i.kt)("br",null),"\nThe Linux ",(0,i.kt)("inlineCode",{parentName:"p"},"gcc")," compiler accepts variable length arrays, while the Windows ",(0,i.kt)("inlineCode",{parentName:"p"},"cl")," compiler ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"does not"))," (the Windows compiler implements remenants of the older 1990 standard, which does not include variable-length arrays.  For more on the language standard, see the chapter entitled ",(0,i.kt)("a",{parentName:"p",href:"/F-Refinements/portability"},"Portability"),").")))}c.isMDXComponent=!0}}]);
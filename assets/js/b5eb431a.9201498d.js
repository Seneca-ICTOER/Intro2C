"use strict";(self.webpackChunkipc144=self.webpackChunkipc144||[]).push([[917],{3905:function(e,n,t){t.d(n,{Zo:function(){return s},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),u=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},s=function(e){var n=u(e.components);return a.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),c=u(t),m=r,h=c["".concat(p,".").concat(m)]||c[m]||d[m]||i;return t?a.createElement(h,l(l({ref:n},s),{},{components:t})):a.createElement(h,l({ref:n},s))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=c;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var u=2;u<i;u++)l[u]=t[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},6132:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return u},toc:function(){return s},default:function(){return c}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),l=["components"],o={id:"library-functions",title:"Library Functions",sidebar_position:6,slug:"/D-Modularity/library-functions",description:"This chapter describes how to use library functions that include functions for mathematical calculations, generation of random events and manipulation and analysis of character data. To access any function within any library we simply include the appropriate header file for that library and call the function in our source code."},p="Library Functions",u={unversionedId:"D-Modularity/library-functions",id:"D-Modularity/library-functions",isDocsHomePage:!1,title:"Library Functions",description:"This chapter describes how to use library functions that include functions for mathematical calculations, generation of random events and manipulation and analysis of character data. To access any function within any library we simply include the appropriate header file for that library and call the function in our source code.",source:"@site/docs/D-Modularity/library-functions.md",sourceDirName:"D-Modularity",slug:"/D-Modularity/library-functions",permalink:"/D-Modularity/library-functions",editUrl:"https://github.com/Seneca-ICTOER/IPC144/tree/main/docs/D-Modularity/library-functions.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"library-functions",title:"Library Functions",sidebar_position:6,slug:"/D-Modularity/library-functions",description:"This chapter describes how to use library functions that include functions for mathematical calculations, generation of random events and manipulation and analysis of character data. To access any function within any library we simply include the appropriate header file for that library and call the function in our source code."},sidebar:"courseNotesSidebar",previous:{title:"Output Functions",permalink:"/D-Modularity/modularity/output-functions"},next:{title:"Text Files",permalink:"/E-Secondary-Storage/text-files"}},s=[{value:"Learning Outcomes",id:"learning-outcomes",children:[],level:2},{value:"Introduction",id:"introduction",children:[],level:2},{value:"Mathematical Functions",id:"mathematical-functions",children:[{value:"Standard Library",id:"standard-library",children:[],level:3},{value:"Integer Absolute Value",id:"integer-absolute-value",children:[],level:3},{value:"Random Numbers",id:"random-numbers",children:[],level:3},{value:"math (Optional)",id:"math-optional",children:[],level:3},{value:"Floating-Point Absolute Value",id:"floating-point-absolute-value",children:[],level:3},{value:"Floor",id:"floor",children:[],level:3},{value:"Ceiling",id:"ceiling",children:[],level:3},{value:"Rounding",id:"rounding",children:[],level:3},{value:"Truncating",id:"truncating",children:[],level:3},{value:"Square Root",id:"square-root",children:[],level:3},{value:"Powers",id:"powers",children:[],level:3},{value:"Logarithms",id:"logarithms",children:[],level:3},{value:"Powers of e",id:"powers-of-e",children:[],level:3}],level:2},{value:"Time Functions (Optional)",id:"time-functions-optional",children:[{value:"Calendar Time",id:"calendar-time",children:[],level:3},{value:"Process Time",id:"process-time",children:[],level:3}],level:2},{value:"Character",id:"character",children:[{value:"Manipulation",id:"manipulation",children:[],level:3},{value:"Analysis",id:"analysis",children:[],level:3}],level:2}],d={toc:s};function c(e){var n=e.components,t=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"library-functions"},"Library Functions"),(0,i.kt)("h2",{id:"learning-outcomes"},"Learning Outcomes"),(0,i.kt)("p",null,"After reading this section, you will be able to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Implement algorithms using standard library procedures to incorporate existing technology")),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"The standard libraries that support programming languages perform many common tasks. C compilers ship with the libraries that include functions for mathematical calculations, generation of random events and manipulation and analysis of character data. To access any function within any library we simply include the appropriate header file for that library and call the function in our source code."),(0,i.kt)("p",null,"This chapter introduces some of the more common functions in the libraries that ship with C compilers. The ",(0,i.kt)("a",{parentName:"p",href:"http://www.gnu.org/software/libc/manual/html_node/index.html"},"GNU Documentation")," includes a comprehensive description of each function in each library."),(0,i.kt)("h2",{id:"mathematical-functions"},"Mathematical Functions"),(0,i.kt)("p",null,"The mathematics related libraries that contain the more common mathematical functions are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"stdlib")," - the standard library"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"math")," - the math library")),(0,i.kt)("h3",{id:"standard-library"},"Standard Library"),(0,i.kt)("p",null,"The header file ",(0,i.kt)("inlineCode",{parentName:"p"},"<stdlib.h>")," contains prototypes for the functions that perform the more general mathematical calculations. These calculations include ",(0,i.kt)("strong",{parentName:"p"},"absolute")," values of ",(0,i.kt)("strong",{parentName:"p"},"integers")," and ",(0,i.kt)("strong",{parentName:"p"},"random")," number generation."),(0,i.kt)("h3",{id:"integer-absolute-value"},"Integer Absolute Value"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"abs()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"labs()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"llabs()")," return the absolute value of the argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int abs(int);\nlong labs(long);\nlong long llabs(long long);\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdlib.h>\n#include <stdio.h>\n\nint main(void)\n{\n        int x = -12;\n        long y = -24L;\n\n        printf("|%d| is %d\\n", x, abs(x));\n        printf("|%ld| is %ld\\n", y, labs(y));\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"|-12| is 12\n|-24| is 24\n")),(0,i.kt)("h3",{id:"random-numbers"},"Random Numbers"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"rand()")," returns a pseudo-random integer in the range ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"RAND_MAX"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"RAND_MAX")," is implementation-dependent but ",(0,i.kt)("strong",{parentName:"p"},"no less")," than ",(0,i.kt)("inlineCode",{parentName:"p"},"32767"),". The prototype for ",(0,i.kt)("inlineCode",{parentName:"p"},"rand()")," is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int rand(void);\n")),(0,i.kt)("p",null,"The following program outputs the same set of 10 pseudo-random integers for each successive run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdlib.h>\n#include <stdio.h>\n\nint main(void)\n{\n        int i;\n\n        for (i = 0; i < 10 ; i++)\n                printf("Random number %d is %d\\n", i+1, rand());\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The following program outputs the same set of 10 pseudo-random integers between ",(0,i.kt)("inlineCode",{parentName:"p"},"6")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"100")," inclusive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdlib.h>\n#include <stdio.h>\n\nint main(void)\n{\n        int i, n, a = 6, b = 100;\n\n        for (i = 0; i < 10 ; i++) {\n                n = a + rand() % (b + 1 - a);\n                printf("Random number %d is %d\\n", i+1, n);\n        }\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The following program outputs the same set of 10 pseudo-random floating-point numbers between ",(0,i.kt)("inlineCode",{parentName:"p"},"3.0")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"100.0")," inclusive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},' #include <stdlib.h>\n #include <stdio.h>\n\nint main(void)\n{\n        int i;\n        double x, a = 3.0, b = 100.0;\n\n        for (i = 0; i < 10 ; i++)\n        {\n                x = a + ((double) rand() / RAND_MAX * (b - a));\n                printf("Random number %d is %.2lf\\n", i+1, x);\n        }\n\n        return 0;\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"rand()")," generates the ",(0,i.kt)("strong",{parentName:"p"},"same set of random numbers")," for every run of its host application. This is very useful during the debugging stage. To generate a different set of random numbers for every run we add a call to the function ",(0,i.kt)("inlineCode",{parentName:"p"},"srand()"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"srand()")," sets the ",(0,i.kt)("strong",{parentName:"p"},"seed")," for the random number generator. The prototype for ",(0,i.kt)("inlineCode",{parentName:"p"},"srand()")," is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int srand(unsigned seed);\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"unsigned")," is a type that only holds ",(0,i.kt)("strong",{parentName:"p"},"non-negative")," integer values. We call ",(0,i.kt)("inlineCode",{parentName:"p"},"srand()")," once with ",(0,i.kt)("inlineCode",{parentName:"p"},"time(NULL)")," as the argument (see below) before the first call to ",(0,i.kt)("inlineCode",{parentName:"p"},"rand()"),", typically at the start of our program. This provides a ",(0,i.kt)("strong",{parentName:"p"},"unique seed for each run")," and hence different pseudo-random numbers."),(0,i.kt)("p",null,"The following program outputs a different set of 10 pseudo-random numbers with every run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdlib.h>\n#include <stdio.h>\n#include <time.h> // prototype for time(NULL)\n\nint main(void)\n{\n        int i;\n\n        srand(time(NULL)); // will set a unique seed for each run of the program\n        for (i = 0; i < 10 ; i++) // iterate with \u201ci\u201d as index\n                printf("Random number %d is %d\\n", i+1, rand());\n\n        return 0;\n}\n')),(0,i.kt)("h3",{id:"math-optional"},"math (Optional)"),(0,i.kt)("p",null,"The math library contains many functions that perform mathematical calculations. Their prototypes are listed in ",(0,i.kt)("inlineCode",{parentName:"p"},"<math.h>"),". To compile a program that uses one of these functions with the gcc compiler, we add the -lm option to the command line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"gcc myProgram.c -lm\n")),(0,i.kt)("h3",{id:"floating-point-absolute-value"},"Floating-Point Absolute Value"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fabs()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"fabsf()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"fabsl()")," return the absolute value of the argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double fabs(double);\nfloat fabsf(float);\nlong double fabsl(long double);\n")),(0,i.kt)("p",null,"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <math.h>\n#include <stdio.h>\n\nint main(void)\n{\n        float w = -12.5;\n        double x = -12.5;\n\n        printf("|%f| is %f\\n", w, fabsf(w));\n        printf("|%lf| is %lf\\n", x, fabs(x));\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"|-12.500000| is 12.500000\n|-12.500000| is 12.500000\n")),(0,i.kt)("h3",{id:"floor"},"Floor"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"floor()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"floorf()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"floorl()")," return the largest integer value not greater than the argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double floor(double);\nfloat floorf(float);\nlong double floorl(long double);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"floor(16.3)")," returns a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"16.0"),"."),(0,i.kt)("h3",{id:"ceiling"},"Ceiling"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ceil()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ceilf()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ceill()")," return the smallest integer value not less than the argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double ceil(double);\nfloat ceilf(float);\nlong double ceill(long double);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"ceil(16.3)")," has a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"17.0"),"."),(0,i.kt)("h3",{id:"rounding"},"Rounding"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"round()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"roundf()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"roundl()")," return the integer value closest to the argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double round(double);\nfloat roundf(float);\nlong double roundl(long double);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"round(16.3)")," has a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"16.0"),", while ",(0,i.kt)("inlineCode",{parentName:"p"},"round(-16.3)")," returns a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"-16.0"),"."),(0,i.kt)("h3",{id:"truncating"},"Truncating"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trunc()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"truncf()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"truncl()")," return the integer part of the argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double trunc(double);\nfloat truncf(float);\nlong double truncl(long double);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"trunc(16.7)")," has a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"16.0"),", while ",(0,i.kt)("inlineCode",{parentName:"p"},"trunc(-16.7)")," returns a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"-16.0"),"."),(0,i.kt)("h3",{id:"square-root"},"Square Root"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sqrt()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"sqrtf()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"sqrtl()")," return the square root of the argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double sqrt(double);\nfloat sqrtf(float);\nlong double sqrtl(long double);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"sqrt(16.0)")," returns a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"4.0"),"."),(0,i.kt)("h3",{id:"powers"},"Powers"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"pow()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"powf()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"powl()")," return the result of the first argument raised to the power of the second argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double pow(double base, double exponent);\nfloat powf(float base, float exponent);\nlong double powl(long double base, long double exponent);\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <math.h>\n#include <stdio.h>\n\nint main(void)\n{\n        double base = 12.5;\n\n        printf("%lf^3 is %lf\\n", base,\n        pow(base,3));\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"12.500000^3 is 1953.125000\n")),(0,i.kt)("p",null,"This set of functions was designed for floating-point arguments and each one is computationally intensive. Avoid using them for simpler integer arguments."),(0,i.kt)("h3",{id:"logarithms"},"Logarithms"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"log()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logf()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logl()")," return the natural logarithm of the argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double log(double);\nfloat logf(float);\nlong double logl(long double);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"log(2.718281828459045)")," returns a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1.0"),"."),(0,i.kt)("h3",{id:"powers-of-e"},"Powers of e"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"exp()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"expf()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"expl()")," return the natural anti-logarithm of the argument. Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double exp(double);\nfloat expf(float);\nlong double expl(long double);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"exp(1.0)")," returns a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"2.718281828459045"),"."),(0,i.kt)("h2",{id:"time-functions-optional"},"Time Functions (Optional)"),(0,i.kt)("p",null,"The time library contains functions that return timing data. Their prototypes are listed in ",(0,i.kt)("inlineCode",{parentName:"p"},"<time.h>"),"."),(0,i.kt)("h3",{id:"calendar-time"},"Calendar Time"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"time")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"time(NULL)")," returns the current calendar time. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"time_t time(time_t *);\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"time_t")," is a type that it is sufficiently large to hold time values - for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"unsigned long"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"difftime")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"difftime()")," returns the difference in ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"seconds"))," between two calendar time arguments. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"double difftime(time_t, time_t);\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"time_t")," is a type that it is sufficiently large to hold time values - for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"unsigned long"),"."),(0,i.kt)("p",null,"The following program returns the time in seconds taken to execute the central iteration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <time.h>\n#include <stdio.h>\n#define NITER 1000000000\n\nint main(void)\n{\n        double x;\n        int i, j, k;\n        time_t t0, t1;\n\n        x = 1;\n        t0 = time(NULL);\n        for (i = 0; i < NITER; i++)\n                x = x * 1.0000000001;\n\n        t1 = time(NULL);\n        printf("Elapsed time is %.1lf secs\\n", difftime(t1, t0));\n        printf("Value of x is %.10lf\\n", x);\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Elapsed time is 40.0 secs\nValue of x is 1.1051709272\n")),(0,i.kt)("h3",{id:"process-time"},"Process Time"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"clock")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"clock()")," returns the approximate process time. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"clock_t clock(void);\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"clock_t")," is a type that holds time values - for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"unsigned long"),". The value is in units of ",(0,i.kt)("inlineCode",{parentName:"p"},"CLOCKS_PER_SEC"),". We divide by these units to obtain the process time in seconds."),(0,i.kt)("p",null,"The following program returns the process time in seconds taken to execute the central iteration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <time.h>\n#include <stdio.h>\n#define NITER 400\n\nint main(void)\n{\n        double x;\n        int i, j, k;\n        time_t t0, t1;\n        clock_t c0, c1;\n\n        x = 1;\n        t0 = time(NULL);\n        c0 = clock();\n        for (i = 0; i < NITER; i++)\n            for (j = 0; j < NITER; j++)\n                for (k = 0; k < NITER; k++)\n                    x = x * 1.0000000001;\n        t1 = time(NULL);\n        c1 = clock();\n        printf("Elapsed time is %.1lf secs\\n",\n            difftime(t1, t0));\n        printf("Process time is %.3lf secs\\n",\n            (double)(c1-c0)/CLOCKS_PER_SEC);\n        printf("Value of x is %.10lf\\n", x);\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Elapsed time is 1.0 secs\nProcess time is 0.040 secs\nValue of x is 1.0001000050\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note, the cast to a ",(0,i.kt)("inlineCode",{parentName:"p"},"double")," forces floating-point division.")),(0,i.kt)("h2",{id:"character"},"Character"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ctype")," library contains functions for character manipulation and analysis. Their prototypes are listed in ",(0,i.kt)("inlineCode",{parentName:"p"},"<ctype.h>"),"."),(0,i.kt)("h3",{id:"manipulation"},"Manipulation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"tolower")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tolower()")," returns the lower case of the character received, if possible; otherwise, the character received unchanged. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int tolower(int);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"tolower('D')")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"'d'"),", while ",(0,i.kt)("inlineCode",{parentName:"p"},"tolower(';')")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"';'"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"toupper")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"toupper()")," returns the upper case of the character received, if possible; otherwise, the character received unchanged. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int toupper(int);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"toupper('d')")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"'D'"),", while ",(0,i.kt)("inlineCode",{parentName:"p"},"toupper(';')")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"';'"),"."),(0,i.kt)("h3",{id:"analysis"},"Analysis"),(0,i.kt)("p",null,"The character analysis functions return 'true' or 'false'. ",(0,i.kt)("strong",{parentName:"p"},"C represents 'false' by the value 0")," and 'true' by ",(0,i.kt)("strong",{parentName:"p"},"any other value"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"islower")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"islower()")," returns a true value if the character received is lower case, a false value otherwise. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int islower(int);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"islower('d')")," returns a true value, while ",(0,i.kt)("inlineCode",{parentName:"p"},"islower('E')")," returns a false value."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"isupper")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"isupper()")," returns a true value if the character received is upper case, a false value otherwise. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int isupper(int);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"isupper('d')")," returns a false value, while ",(0,i.kt)("inlineCode",{parentName:"p"},"isupper('E')")," returns a true value."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"isalpha")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"isalpha()")," returns a true value if the character received is alphabetic, a false value otherwise. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int isalpha(int);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"isalpha('d')")," returns true, while ",(0,i.kt)("inlineCode",{parentName:"p"},"isalpha('6')")," returns false."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"isdigit")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"isdigit()")," returns a true value if the character received is a digit, a false value otherwise. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int isdigit(int);\n\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"isdigit('d')")," returns false, while ",(0,i.kt)("inlineCode",{parentName:"p"},"isdigit('6')")," returns true."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"isspace")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"isspace()")," returns a true value if the character received is a whitespace character, a false value otherwise. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int isspace(int);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"isspace('d')")," returns false, while ",(0,i.kt)("inlineCode",{parentName:"p"},"isspace(' ')")," returns true. Whitespace characters are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"' '")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'\\t'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'\\n'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'\\v'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'\\f'"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"isblank")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"isblank()")," returns a true value if the character received is a space or tab, a false value otherwise. The prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int isblank(int);\n")),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"isblank('\\t')")," returns true, while ",(0,i.kt)("inlineCode",{parentName:"p"},"isblank('\\n')")," returns false."))}c.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkipc144=self.webpackChunkipc144||[]).push([[389],{3905:function(t,e,n){n.d(e,{Zo:function(){return d},kt:function(){return h}});var a=n(7294);function l(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){l(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,l=function(t,e){if(null==t)return{};var n,a,l={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(l[n]=t[n]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(l[n]=t[n])}return l}var s=a.createContext({}),u=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},d=function(t){var e=u(t.components);return a.createElement(s.Provider,{value:e},t.children)},c={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},p=a.forwardRef((function(t,e){var n=t.components,l=t.mdxType,r=t.originalType,s=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),p=u(n),h=l,k=p["".concat(s,".").concat(h)]||p[h]||c[h]||r;return n?a.createElement(k,i(i({ref:e},d),{},{components:n})):a.createElement(k,i({ref:e},d))}));function h(t,e){var n=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=n.length,i=new Array(r);i[0]=p;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o.mdxType="string"==typeof t?t:l,i[1]=o;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5197:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return d},default:function(){return p}});var a=n(7462),l=n(3366),r=(n(7294),n(3905)),i=["components"],o={id:"functions-arrays-and-structs",title:"Functions, Arrays and Structs",sidebar_position:3,description:"Describes how to identify a function type, the different scopes within a program, the passing of arrays and structures to a function, and list-style guidelines"},s="Functions, Arrays and Structs",u={unversionedId:"D-Modularity/functions-arrays-and-structs",id:"D-Modularity/functions-arrays-and-structs",isDocsHomePage:!1,title:"Functions, Arrays and Structs",description:"Describes how to identify a function type, the different scopes within a program, the passing of arrays and structures to a function, and list-style guidelines",source:"@site/docs/D-Modularity/functions-arrays-and-structs.md",sourceDirName:"D-Modularity",slug:"/D-Modularity/functions-arrays-and-structs",permalink:"/D-Modularity/functions-arrays-and-structs",editUrl:"https://github.com/Seneca-ICTOER/Intro2C/tree/main/docs/D-Modularity/functions-arrays-and-structs.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"functions-arrays-and-structs",title:"Functions, Arrays and Structs",sidebar_position:3,description:"Describes how to identify a function type, the different scopes within a program, the passing of arrays and structures to a function, and list-style guidelines"},sidebar:"courseNotesSidebar",previous:{title:"Pointers",permalink:"/D-Modularity/pointers"},next:{title:"Input Functions",permalink:"/D-Modularity/input-functions"}},d=[{value:"Learning Outcomes",id:"learning-outcomes",children:[],level:2},{value:"Introduction",id:"introduction",children:[],level:2},{value:"Prototypes",id:"prototypes",children:[{value:"include",id:"include",children:[],level:3},{value:"Current Directory(Optional)",id:"current-directoryoptional",children:[],level:3}],level:2},{value:"Scope",id:"scope",children:[{value:"Global Scope",id:"global-scope",children:[],level:3},{value:"Function Scope",id:"function-scope",children:[],level:3},{value:"Local Scope",id:"local-scope",children:[],level:3},{value:"Block Scope",id:"block-scope",children:[],level:3},{value:"Overlapping Scope (Optional)",id:"overlapping-scope-optional",children:[],level:3}],level:2},{value:"Passing Arrays",id:"passing-arrays",children:[{value:"Array Arguments",id:"array-arguments",children:[],level:3},{value:"Parameters",id:"parameters",children:[],level:3},{value:"Barring Changes",id:"barring-changes",children:[],level:3}],level:2},{value:"Passing Structures",id:"passing-structures",children:[{value:"Copying",id:"copying",children:[],level:3},{value:"Efficiency",id:"efficiency",children:[],level:3},{value:"Arrow Notation",id:"arrow-notation",children:[],level:3}],level:2},{value:"Style",id:"style",children:[{value:"Documentation",id:"documentation",children:[],level:3}],level:2},{value:"Structure Walkthrough",id:"structure-walkthrough",children:[],level:2}],c={toc:d};function p(t){var e=t.components,o=(0,l.Z)(t,i);return(0,r.kt)("wrapper",(0,a.Z)({},c,o,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"functions-arrays-and-structs"},"Functions, Arrays and Structs"),(0,r.kt)("h2",{id:"learning-outcomes"},"Learning Outcomes"),(0,r.kt)("p",null,"After reading this section, you will be able to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Design procedures using selection and iteration constructs to solve a programming task"),(0,r.kt)("li",{parentName:"ul"},"Connect procedures using pass-by-value and pass-by-address semantics to build a complete program"),(0,r.kt)("li",{parentName:"ul"},"Design data collections using arrays and structures to manage information efficiently"),(0,r.kt)("li",{parentName:"ul"},"Trace the execution of a complete program to validate its correctness")),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Procedural programming scopes information. Scoping is an essential feature of modular design. A complete program consists of a variety of scopes. Each module limits the visibility of the program data and instructions in that module. Each code block limits the visibility of the data in that block."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Hierarchical view of global, function and block scope",src:n(1303).Z})),(0,r.kt)("p",null,"This chapter describes how to identify a function type, describes the different scopes within a program, describes the passing of arrays and structures to a function, lists style guidelines for function coding and provides a sample walkthrough with functions, pointers and structures."),(0,r.kt)("h2",{id:"prototypes"},"Prototypes"),(0,r.kt)("p",null,"A function prototype identifies a function type. It provides the information that the compiler requires to validate a function call. The prototype is similar to the function header. A prototype takes the following form"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"type identifier(type [parameter], ..., type [parameter]);\n")),(0,r.kt)("p",null,"A prototype ends with a semi-colon and may exclude the parameter identifiers. The identifier, the return type, and the parameter types are sufficient to validate a function call. The parameter types determine any coercion that may be necessary in passing values to the function."),(0,r.kt)("p",null,"For example, the prototype for our power() function in the chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/D-Modularity/functions"},"Functions")," is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"int power(int, int);\n")),(0,r.kt)("p",null,"We insert prototypes near the head of our source file and before any function calls. Once we have declared the prototype for each function in a source file, we can arrange our function definitions in any order."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'/* Raise an integer to the power of a integer\n * power.c\n */\n\n#include <stdio.h>\n\nint power(int base, int exponent);\n\nint main(void)\n{\n        int base, exp, answer;\n\n        printf("Enter base : ");\n        scanf("%d", &base);\n        printf("Enter exponent : ");\n        scanf("%d", &exp);\n\n        answer = power(base, exp);\n        printf("%d^%d = %d\\n", base, exp, answer);\n\n        return 0;\n}\n\nint power(int base, int exponent)\n{\n        int result, i;\n\n        result = 1;\n        for (i = 0; i < exponent; i++)\n                result = result * base;\n\n        return result;\n}\n')),(0,r.kt)("p",null,"The compiler interprets the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"power()")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," function as a valid call based on the prototype (not the header in the function definition below the call)."),(0,r.kt)("h3",{id:"include"},"include"),(0,r.kt)("p",null,"We can define a function used by our host application in a file separate from the source file of our application. If we do, we also store its prototype in a separate file called a header file. Typically, this header file has the extension ",(0,r.kt)("inlineCode",{parentName:"p"},".h"),". We insert the contents of the header file into the source file of our application using a ",(0,r.kt)("inlineCode",{parentName:"p"},"#include")," directive."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"#include")," directive takes either of two forms:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <filename>  // filename is in the system directories\n#include "filename"  // filename is in the current directory\n')),(0,r.kt)("p",null,"The compiler searches for the header file in the current directory, the system directory or both and, if found, inserts the contents of the file in place of the directive."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"stdio.h")),(0,r.kt)("p",null,"The header file that contains the prototypes for the ",(0,r.kt)("inlineCode",{parentName:"p"},"printf()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"scanf()")," functions is called ",(0,r.kt)("inlineCode",{parentName:"p"},"stdio.h")," and is stored in a ",(0,r.kt)("strong",{parentName:"p"},"system directory"),"."),(0,r.kt)("p",null,"We include this header file in our source code whenever we call either of these functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n\nint main(void)\n{\n        printf("This is C\\n");\n\n        return 0;\n}\n')),(0,r.kt)("h3",{id:"current-directoryoptional"},"Current Directory(Optional)"),(0,r.kt)("p",null,"We may store the prototype for our ",(0,r.kt)("inlineCode",{parentName:"p"},"power()")," function in its own ",(0,r.kt)("strong",{parentName:"p"},"header file (.h)")," and insert that header file in our source code. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/* Raise an integer to the power of a integer\n * power.h\n */\n\nint power(int base, int exponent);\n")),(0,r.kt)("p",null,"The corresponding ",(0,r.kt)("strong",{parentName:"p"},"implementation file (.c)")," will look like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'/* Raise an integer to the power of a integer\n * power.c\n */\n\n#include <stdio.h>\n\n#include "power.h"\n\nint main(void)\n{\n        int base, exp, answer;\n\n        printf("Enter base : ");\n        scanf("%d", &base);\n        printf("Enter exponent : ");\n        scanf("%d", &exp);\n\n        answer = power(base, exp);\n        printf("%d^%d = %d\\n", base, exp, answer);\n\n        return 0;\n}\n\nint power(int base, int exponent)\n{\n        int result, i;\n\n        result = 1;\n        for (i = 0; i < exponent; i++)\n                result = result * base;\n\n        return result;\n}\n')),(0,r.kt)("h2",{id:"scope"},"Scope"),(0,r.kt)("p",null,"The scope of a program identifier determines its visibility. Its scope depends on where we have placed its definition. A program variable may have"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"global scope"),(0,r.kt)("li",{parentName:"ul"},"function scope"),(0,r.kt)("li",{parentName:"ul"},"local scope"),(0,r.kt)("li",{parentName:"ul"},"block scope")),(0,r.kt)("h3",{id:"global-scope"},"Global Scope"),(0,r.kt)("p",null,"A variable ",(0,r.kt)("strong",{parentName:"p"},"declared outside all function definitions")," has ",(0,r.kt)("em",{parentName:"p"},"global scope"),". We call such a variable a ",(0,r.kt)("em",{parentName:"p"},"global variable"),". Any program instruction can access a global variable. The compiler allocates memory for a global variable alongside the string literals at startup and releases that memory at termination; that is, after the having executed the ",(0,r.kt)("inlineCode",{parentName:"p"},"return")," statement of ",(0,r.kt)("inlineCode",{parentName:"p"},"main()"),"."),(0,r.kt)("p",null,"Global variables introduce a high degree of coupling. For instance, if we change the name of the variable in its definition, we need to change it in all functions that reference that variable. Because of this high degree of coupling, we avoid global variables altogether. Their presence complicates maintainability: if 1000s of functions reference the variable, changing its name proves to be a nightmare."),(0,r.kt)("h3",{id:"function-scope"},"Function Scope"),(0,r.kt)("p",null,"A variable that we ",(0,r.kt)("strong",{parentName:"p"},"declare within a function header")," has ",(0,r.kt)("em",{parentName:"p"},"function scope"),". We call such variables ",(0,r.kt)("em",{parentName:"p"},"function parameters"),". The scope of the parameter extends from the function header to the closing brace of the function body. We say that the parameter goes out of scope at this closing brace."),(0,r.kt)("p",null,"The compiler allocates memory for a function parameter when the function is called and releases that memory when the function return control to its caller. C compilers initialize the values of the function parameters to the values of the arguments in the function call."),(0,r.kt)("h3",{id:"local-scope"},"Local Scope"),(0,r.kt)("p",null,"A variable that we ",(0,r.kt)("strong",{parentName:"p"},"declare within a function body")," has ",(0,r.kt)("em",{parentName:"p"},"local scope"),". We call such variables ",(0,r.kt)("em",{parentName:"p"},"local variables"),". The scope of the variable extends from its definition to the end of the code block within which we declared the variable. We say that the variable goes out of scope at the closing brace of its code block."),(0,r.kt)("p",null,"The compiler allocates memory for a local variable where it is defined (or first used) and releases that memory when the variable goes out of scope. C compilers do not initialize the values of local variables."),(0,r.kt)("h3",{id:"block-scope"},"Block Scope"),(0,r.kt)("p",null,"A variable that we ",(0,r.kt)("strong",{parentName:"p"},"declare within a code block")," has ",(0,r.kt)("em",{parentName:"p"},"block scope"),". The scope of the variable extends from its definition to the end of the code block within which we declared the variable. We say that the variable goes out of scope at the closing brace of its code block."),(0,r.kt)("h3",{id:"overlapping-scope-optional"},"Overlapping Scope (Optional)"),(0,r.kt)("p",null,"A variable occupies its own memory location from its declaration to the end of its parent code block. We refer to this period as the variable's ",(0,r.kt)("em",{parentName:"p"},"lifetime"),". A variable is visible throughout its lifetime as long as it is not hidden by another variable of the same name."),(0,r.kt)("p",null,"Consider the following program. The variable ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," within the code block hides the local parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," until the end of the iteration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'/* Avoid Variables of the Same Name\n * lifetime.c\n */\n\n#include <stdio.h>\n\nvoid foo(int x)\n{\n        int i = 4;\n        do {\n                int x = i;\n                printf("%d ", x);\n                i--;\n        } while(i > 0);\n        printf("%d ", x);\n}\n\nint main(void)\n{\n        foo(6);\n        return 0;\n}\n')),(0,r.kt)("p",null,"The program above will produce the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"4 3 2 1 6\n")),(0,r.kt)("p",null,"We say that the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," declared within the code block ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"shadows"))," the parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," declared in the function header."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Using the same name for two distinct variables with overlapping lifetimes only introduces confusion. Although compilers accept such code, it is poor style and best avoided altogether.")),(0,r.kt)("h2",{id:"passing-arrays"},"Passing Arrays"),(0,r.kt)("p",null,"The elements of an array occupy contiguous locations in memory. Because of this accessing any element from within a function only requires the address of the start of the array and the element index."),(0,r.kt)("p",null,"The name of an array without the brackets holds the address of the start of the array."),(0,r.kt)("h3",{id:"array-arguments"},"Array Arguments"),(0,r.kt)("p",null,"To grant a function access to an array, we pass the array's address as an argument in the function call. The call takes the form"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"function_identifier(array_identifier, ... )\n")),(0,r.kt)("p",null,"By passing the address, we avoid copying the entire array. The decision to pass arrays in this way was made when the C language was designed."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"// Passing an Array to a Function\n// passArray.c\n\n#include <stdio.h>\n#define NGRADES 8\n\n// definition of display() ...\n\nint main(void)\n{\n        int grade[] = {10,9,10,8,7,9,8,10};\n\n        display(grade, NGRADES);\n\n        return 0;\n}\n")),(0,r.kt)("h3",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,"A function header that receives an array's address takes the form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"type function_identifier(type array_identifier[], ... )\n")),(0,r.kt)("p",null,"or"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"type function_identifier(type *array_identifier, ... )\n")),(0,r.kt)("p",null,"The empty brackets following ",(0,r.kt)("inlineCode",{parentName:"p"},"identifier")," in the first alternative tell the compiler that the parameter holds the address of a one-dimensional array. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// array using []\nvoid display(int g[], int n)\n{\n       for(i = 0; i < n; i++)\n               printf("%d ", g[i]);\n}\n')),(0,r.kt)("p",null,"OR:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// array using * (pointer)\nvoid display(int *g, int n)\n{\n       for(i = 0; i < n; i++)\n               printf("%d ", g[i]);\n}\n')),(0,r.kt)("p",null,"Because we have passed the address of the array and not a copy of all of its elements, any change to an element within the function will change the array element in the caller."),(0,r.kt)("h3",{id:"barring-changes"},"Barring Changes"),(0,r.kt)("p",null,"To prevent a function from changing any element of an array identified by a function parameter, we qualify the parameter as ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),". The function header takes the form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"type function_identifier(const type array_identifier[], ... )\n")),(0,r.kt)("p",null,"OR:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"type function_identifier(const type *array_identifier, ... )\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// array using []\nvoid display(const int g[], int n)\n{\n       for(i = 0; i < n; i++)\n               printf("%d ", g[i]);\n}\n')),(0,r.kt)("p",null,"OR:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// array using * (pointer)\nvoid display(const int *g, int n)\n{\n       for(i = 0; i < n; i++)\n               printf("%d ", g[i]);\n}\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Any attempt to modify the value of an element of ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," will generate a compiler error. Without the ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," keyword, we could reset the value of the first element to 10 by adding a statement like ",(0,r.kt)("inlineCode",{parentName:"p"},"g[0] = 10;"),".")),(0,r.kt)("h2",{id:"passing-structures"},"Passing Structures"),(0,r.kt)("p",null,"We can pass an object of structure type to a function in either of two ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"pass by value"),(0,r.kt)("li",{parentName:"ul"},"pass by address"),(0,r.kt)("li",{parentName:"ul"},"Pass By Value")),(0,r.kt)("p",null,"Consider the following program. Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"Student")," structure includes a member that identifies the number of grades filled. We pass ",(0,r.kt)("inlineCode",{parentName:"p"},"harry")," as a single argument to ",(0,r.kt)("inlineCode",{parentName:"p"},"display()")," and access its member within the function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// Passing a structure to a function\n// pass_by_value.c\n\n#include <stdio.h>\n\nstruct Student\n{\n        int no;\n        int no_grades_filled;\n        float grade[4];\n};\n\nvoid display(const struct Student s);  // pass by value\n\nint main(void)\n{\n        struct Student harry = {975, 3,\n         {75.6f, 82.3f, 68.9f, 0.0f}};\n\n        display(harry);\n}\n\nvoid display(const struct Student st)\n{\n        int i;\n        printf("Grades for %d\\n", st.no);\n        for (i = 0; i < st.no_grades_filled; i++)\n                printf("%.1f\\n", st.grade[i]);\n}\n')),(0,r.kt)("p",null,"The above program produces the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Grades for 975\n75.6\n82.3\n68.9\n")),(0,r.kt)("p",null,"The declaration of ",(0,r.kt)("inlineCode",{parentName:"p"},"Student")," precedes the prototype for ",(0,r.kt)("inlineCode",{parentName:"p"},"display()"),". The compiler needs this declaration to interpret the parameter type in the prototype."),(0,r.kt)("p",null,"The C compiler passes objects of structure type by value. It copies the value of the argument in the function call into the parameter, as its initial value. Any change within the function affects only the copy and not the original value."),(0,r.kt)("p",null,"In the following example, the data stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"harry")," does not change after the function ",(0,r.kt)("inlineCode",{parentName:"p"},"set()")," returns control to ",(0,r.kt)("inlineCode",{parentName:"p"},"main()"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// Pass by Value\n// pass_by_value.c\n\n#include <stdio.h>\n\nstruct Student\n{\n        int no;\n        int no_grades_filled;\n        float grade[4];\n};\n\nvoid set(struct Student st);\nvoid display(const struct Student st);\n\nint main(void)\n{\n        struct Student harry = { 975, 2, {50.0f, 50.0f}};\n\n        set(harry);\n        display(harry);\n}\n\nvoid set(struct Student st)\n{\n        struct Student harry = {306, 2, {78.9, 91.6}};\n\n        st = harry;\n}\n\nvoid display(const struct Student st)\n{\n        int i;\n        printf("Grades for %d\\n", st.no);\n        for (i = 0; i < st.no_grades_filled; i++)\n                printf("%.1f\\n", st.grade[i]);\n}\n')),(0,r.kt)("p",null,"The above program produces the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Grades for 975\n50.0\n50.0\n")),(0,r.kt)("p",null,"The values in the original object, its copy and the local object are shown in the table below:"),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"int main()")),(0,r.kt)("td",{colSpan:"2"},(0,r.kt)("code",null,"void set()"))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student harry")),(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student st")),(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student harry")))),(0,r.kt)("tbody",null,(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"975 2 50.0f 50.0f"),(0,r.kt)("td",null,"975 2 50.0f 50.0f"),(0,r.kt)("td",null,"\xa0")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"975 2 50.0f 50.0f"),(0,r.kt)("td",null,"975 2 50.0f 50.0f"),(0,r.kt)("td",null,"306 2 78.9f 91.6f")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"975 2 50.0f 50.0f"),(0,r.kt)("td",null,"306 2 78.9f 91.6f"),(0,r.kt)("td",null,"306 2 78.9f 91.6f")))),(0,r.kt)("h3",{id:"copying"},"Copying"),(0,r.kt)("p",null,"The C compiler performs member-by-member copying automatically whenever we:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"pass an object by value"),(0,r.kt)("li",{parentName:"ul"},"assign an object to an existing object"),(0,r.kt)("li",{parentName:"ul"},"initialize a new object using an existing object"),(0,r.kt)("li",{parentName:"ul"},"return an object by value"),(0,r.kt)("li",{parentName:"ul"},"pass by address")),(0,r.kt)("p",null,"To change the data within an original object passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"set()")," function, we require the address of the original object. In the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"set()")," we pass its address. ",(0,r.kt)("inlineCode",{parentName:"p"},"set()")," receives this address in its pointer parameter."),(0,r.kt)("p",null,"In the following program, we pass the address of harry to ",(0,r.kt)("inlineCode",{parentName:"p"},"set()"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// Pass by Address\n// pass_by_address.c\n\n#include <stdio.h>\n\nstruct Student\n{\n        int no;\n        int no_grades_filled;\n        float grade[4];\n};\n\nvoid set(struct Student* st);\nvoid display(const struct Student st);\n\nint main(void)\n{\n        struct Student harry = { 975, 2, {50.0f, 50.0f}};\n\n        set(&harry);\n        display(harry);\n}\n\nvoid set(struct Student* st)\n{\n        struct Student harry = {306, 2, {78.9, 91.6}};\n\n        *st = harry;\n}\n\nvoid display(const struct Student st)\n{\n        int i;\n        printf("Grades for %d\\n", st.no);\n        for (i = 0; i < st.no_grades_filled; i++)\n                printf("%.1f\\n", st.grade[i]);\n}\n')),(0,r.kt)("p",null,"The above program produces the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Grades for 306\n78.9\n91.6\n")),(0,r.kt)("p",null,"The values in the original object and the local object are shown in the table below:"),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"int main()")),(0,r.kt)("td",{colSpan:"2"},(0,r.kt)("code",null,"void set()")),(0,r.kt)("td",null,(0,r.kt)("code",null,"void display()"))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student harry")),(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student *st")),(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student harry")),(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student st")))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,"Address:",(0,r.kt)("br",null),"22ff2b8d4"),(0,r.kt)("td",null,"\xa0",(0,r.kt)("br",null),"22ff2b8ec"),(0,r.kt)("td",null,"\xa0",(0,r.kt)("br",null),"22ff2b8f0"),(0,r.kt)("td",null,"\xa0",(0,r.kt)("br",null),"22ff2b908")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"975 2 50.0f 50.0f"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"306 2 78.9f 91.6f"),(0,r.kt)("td",null,"2ff2b8d4"),(0,r.kt)("td",null,"306 2 78.9f 91.6f"),(0,r.kt)("td",null,"\xa0")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"306 2 78.9f 91.6f"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"306 2 78.9f 91.6f")))),(0,r.kt)("h3",{id:"efficiency"},"Efficiency"),(0,r.kt)("p",null,"Passing an object ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"by address"))," is efficient. It avoids copying all member values, saving time and space especially in cases where a member is an array with a large number of elements. Passing an object by address only copies the address, which typically occupies 4 bytes."),(0,r.kt)("p",null,"Consider passing ",(0,r.kt)("inlineCode",{parentName:"p"},"harry")," by address to function ",(0,r.kt)("inlineCode",{parentName:"p"},"display()")," as well:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// Pass by Address 1\n// pass_by_address_1.c\n\n#include <stdio.h>\n\nstruct Student\n{\n        int no;\n        int no_grades_filled;\n        float grade[4];\n};\n\nvoid set(struct Student* st);\nvoid display(const struct Student* st);\n\nint main(void)\n{\n        struct Student harry = { 975, 2, {50.0f, 50.0f}};\n\n        set(&harry);\n        display(&harry);\n}\n\nvoid set(struct Student* st)\n{\n        struct Student harry = {306, 2, {78.9, 91.6}};\n\n        *st = harry;\n}\n\nvoid display(const struct Student* st)\n{\n        int i;\n        printf("Grades for %d\\n", (*st).no);\n        for (i = 0; i < (*st).no_grades_filled; i++)\n                printf("%.1f\\n", (*st).grade[i]);\n}\n')),(0,r.kt)("p",null,"The above program produces the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Grades for 306\n78.9\n91.6\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"display()")," dereferences the address before selecting the members. Since the dot operator binds tighter than the dereferencing operator, the parentheses are necessary. Omitting them would generate a compiler error (the data member after the dot operator is not of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Student*"),")."),(0,r.kt)("p",null,"If we ",(0,r.kt)("strong",{parentName:"p"},"pass by address")," with no intention of changing that object within the function, we add the ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," qualifier to safeguard against accidental modifications."),(0,r.kt)("p",null,"The values in the original object and the local object are shown in the table below:"),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"int main()")),(0,r.kt)("td",{colSpan:"2"},(0,r.kt)("code",null,"void set()")),(0,r.kt)("td",null,(0,r.kt)("code",null,"void display()"))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student harry")),(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student *st")),(0,r.kt)("td",null,(0,r.kt)("code",null,"struct Student harry")),(0,r.kt)("td",null,(0,r.kt)("code",null,"const struct Student *st")))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,"Address:",(0,r.kt)("br",null),"22ff2b8d4"),(0,r.kt)("td",null,"\xa0",(0,r.kt)("br",null),"22ff2b8ec"),(0,r.kt)("td",null,"\xa0",(0,r.kt)("br",null),"22ff2b8f0"),(0,r.kt)("td",null,"\xa0",(0,r.kt)("br",null),"22ff2b908")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"975 2 50.0f 50.0f"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"306 2 78.9f 91.6f"),(0,r.kt)("td",null,"2ff2b8d4"),(0,r.kt)("td",null,"306 2 78.9f 91.6f"),(0,r.kt)("td",null,"\xa0")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"306 2 78.9f 91.6f"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"2ff2b8d4")))),(0,r.kt)("h3",{id:"arrow-notation"},"Arrow Notation"),(0,r.kt)("p",null,"The syntax ",(0,r.kt)("inlineCode",{parentName:"p"},"(*s).no")," is awkward to read. ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Arrow notation"))," provides cleaner alternative. It takes the form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"address->member\n")),(0,r.kt)("p",null,"The arrow operator takes a pointer to an object on its left and a member identifier on its right."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// Pass by Address 3\n// arrow_notation.c\n\n#include <stdio.h>\n\nstruct Student\n{\n        int no;\n        int no_grades_filled;\n        float grade[4];\n};\n\nvoid set(struct Student* st);\nvoid display(const struct Student* st);\n\nint main(void)\n{\n        struct Student harry = { 975, 2, {50.0f, 50.0f}};\n\n        set(&harry);\n        display(&harry);\n}\n\nvoid set(struct Student* st)\n{\n        struct Student harry = {306, 2, {78.9, 91.6}};\n\n        *st = harry;\n}\n\nvoid display(const struct Student* st)\n{\n        int i;\n        printf("Grades for %d\\n", st->no);\n        for (i = 0; i < st->no_grades_filled; i++)\n                printf("%.1f\\n", st->grade[i]);\n}\n')),(0,r.kt)("p",null,"The above program produces the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Grades for 306\n78.9\n91.6\n")),(0,r.kt)("h2",{id:"style"},"Style"),(0,r.kt)("p",null,"The rules of structured programming extend directly to functions. A structured program does not have multiple returns. We replace multiple return statements with flags logic and a single return statement."),(0,r.kt)("p",null,"It is good programming style to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"place the opening brace on a separate line"),(0,r.kt)("li",{parentName:"ul"},"declare a prototype for each function definition"),(0,r.kt)("li",{parentName:"ul"},"include parameter identifiers in the prototype declaration as documentation"),(0,r.kt)("li",{parentName:"ul"},"use generic comments and variables names to enable future use in different applications without having to modify any of the function code"),(0,r.kt)("li",{parentName:"ul"},"avoid calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"main()")," function recursively"),(0,r.kt)("li",{parentName:"ul"},"limit the number of local variables to below 10, if possible")),(0,r.kt)("h3",{id:"documentation"},"Documentation"),(0,r.kt)("p",null,"We document each function at one level of abstraction above the caller. We precede the function header in the function definition with comments that describe:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"what the function does (not how)"),(0,r.kt)("li",{parentName:"ul"},"what the function needs (in terms of values for its parameters)"),(0,r.kt)("li",{parentName:"ul"},"what the function returns (if anything)")),(0,r.kt)("p",null,"We state any assumption or constraint that applies to using the function."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"// power returns the value of base raised to\n//  the power of exponent (base^exponent)\n//\n//  power assumes that base and exponent are\n//  integer values and exponent is non-negative\n//\nint power(int base, int exponent)\n{\n        int result, i;\n\n        result = 1;\n        for (i = 0; i < exponent; i++)\n            result = result * base;\n\n        return result;\n}\n")),(0,r.kt)("h2",{id:"structure-walkthrough"},"Structure Walkthrough"),(0,r.kt)("p",null,"The following program contains several objects of type A. The walkthrough table is shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'// Structure Types - Walkthrough\n// struct_walk.c\n\n#include <stdio.h>\n\nstruct A\n{\n        int x;\n        double r;\n};\n\nvoid foo(struct A* c);\nstruct A goo(struct A d);\n\nint main(void)\n{\n        struct A a = {4, 6.67}, b;\n\n        foo(&a);\n        printf("00%d.%.3lf.111\\n", a.x, a.r);\n        b = goo(a);\n        printf("00%d.%.3lf.112\\n", a.x, a.r);\n        printf("%d.%.3lf.113\\n", b.x, b.r);\n}\n\nvoid foo(struct A* c)\n{\n        int i;\n\n        i = c->x;\n        c->x = c->r;\n        c->r = c->x % i + 202.134;\n}\n\nstruct A goo(struct A d)\n{\n        struct A e;\n\n        d.x = d.r - 62;\n        e = d;\n        return e;\n}\n')),(0,r.kt)("p",null,"The table includes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the return type for each function"),(0,r.kt)("li",{parentName:"ul"},"the name of each function"),(0,r.kt)("li",{parentName:"ul"},"the structure type of each object"),(0,r.kt)("li",{parentName:"ul"},"the name of each object"),(0,r.kt)("li",{parentName:"ul"},"the type of each member"),(0,r.kt)("li",{parentName:"ul"},"the name of each member")),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"The breakdown of each object into its members in the head of the table. We reserve a separate line for the addresses that are pointed to:"))),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("td",{colSpan:"4"},(0,r.kt)("code",null,"int")),(0,r.kt)("td",{colSpan:"2"},(0,r.kt)("code",null,"void")),(0,r.kt)("td",{colSpan:"4"},(0,r.kt)("code",null,"struct A"))),(0,r.kt)("tr",null,(0,r.kt)("td",{colSpan:"4"},(0,r.kt)("code",null,"main()")),(0,r.kt)("td",{colSpan:"2"},(0,r.kt)("code",null,"foo()")),(0,r.kt)("td",{colSpan:"4"},(0,r.kt)("code",null,"goo()"))),(0,r.kt)("tr",null,(0,r.kt)("td",{colSpan:"2"},(0,r.kt)("code",null,"struct A")),(0,r.kt)("td",{colSpan:"2"},(0,r.kt)("code",null,"struct A")),(0,r.kt)("td",null,(0,r.kt)("code",null,"struct A*")),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",{colSpan:"2"},(0,r.kt)("code",null,"struct A")),(0,r.kt)("td",{colSpan:"2"},(0,r.kt)("code",null,"struct A")))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",{colSpan:"2"},"a"),(0,r.kt)("td",{colSpan:"2"},"b"),(0,r.kt)("td",null,"c"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",{colSpan:"2"},"d"),(0,r.kt)("td",{colSpan:"2"},"e")),(0,r.kt)("tr",null,(0,r.kt)("td",{colSpan:"2"},"Address:",(0,r.kt)("br",null),"1000"),(0,r.kt)("td",{colSpan:"2"},"\xa0",(0,r.kt)("br",null),"100C"),(0,r.kt)("td",null,"\xa0",(0,r.kt)("br",null),"1018"),(0,r.kt)("td",null,"\xa0",(0,r.kt)("br",null),"101C"),(0,r.kt)("td",{colSpan:"2"},"\xa0",(0,r.kt)("br",null),"1020"),(0,r.kt)("td",{colSpan:"2"},"\xa0",(0,r.kt)("br",null),"102C")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"int"),(0,r.kt)("td",null,"double"),(0,r.kt)("td",null,"int"),(0,r.kt)("td",null,"double"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"int"),(0,r.kt)("td",null,"int"),(0,r.kt)("td",null,"double"),(0,r.kt)("td",null,"int"),(0,r.kt)("td",null,"double")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"x"),(0,r.kt)("td",null,"r"),(0,r.kt)("td",null,"x"),(0,r.kt)("td",null,"r"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"i"),(0,r.kt)("td",null,"x"),(0,r.kt)("td",null,"r"),(0,r.kt)("td",null,"x"),(0,r.kt)("td",null,"r")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"1000"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"1000"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"1000"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"1000"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0")),(0,r.kt)("tr",{className:"highlight"},(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"1000"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0"),(0,r.kt)("td",null,"\xa0")))))}p.isMDXComponent=!0},1303:function(t,e,n){e.Z=n.p+"assets/images/scope-27eaba280229d8c880b6b92f9656f8da.png"}}]);
(self.webpackChunkipc_144=self.webpackChunkipc_144||[]).push([[1646],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),m=c(n),d=i,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||o;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=m;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2896:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return m}});var a=n(2122),i=n(9756),o=(n(7294),n(3905)),s=["components"],r={},l="Logic",c={unversionedId:"B-Computations/logic",id:"B-Computations/logic",isDocsHomePage:!1,title:"Logic",description:"Learning Outcomes",source:"@site/docs/B-Computations/logic.md",sourceDirName:"B-Computations",slug:"/B-Computations/logic",permalink:"/IPC144/docs/B-Computations/logic",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/B-Computations/logic.md",version:"current",frontMatter:{},sidebar:"courseNotesSidebar",previous:{title:"Expressions",permalink:"/IPC144/docs/B-Computations/expressions"},next:{title:"Style Guidelines",permalink:"/IPC144/docs/B-Computations/style-guidelines"}},p=[{value:"Learning Outcomes",id:"learning-outcomes",children:[]},{value:"Introduction",id:"introduction",children:[]},{value:"Structured Programming",id:"structured-programming",children:[]},{value:"Preliminary Design",id:"preliminary-design",children:[{value:"Pseudo-Code",id:"pseudo-code",children:[]},{value:"Flow Charts",id:"flow-charts",children:[]}]},{value:"Selection Constructs",id:"selection-constructs",children:[{value:"Optional Path",id:"optional-path",children:[]},{value:"Alternative Paths",id:"alternative-paths",children:[]},{value:"Conditional Expression",id:"conditional-expression",children:[]}]},{value:"Iteration Constructs",id:"iteration-constructs",children:[{value:"while",id:"while",children:[]},{value:"do while",id:"do-while",children:[]},{value:"for",id:"for",children:[]}]},{value:"Flags",id:"flags",children:[{value:"Avoid Jumps (Optional)",id:"avoid-jumps-optional",children:[]}]},{value:"Nested Constructs",id:"nested-constructs",children:[{value:"Nested Selections",id:"nested-selections",children:[]},{value:"Dangling Else",id:"dangling-else",children:[]},{value:"Nested Iterations",id:"nested-iterations",children:[]}]}],u={toc:p};function m(e){var t=e.components,n=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"logic"},"Logic"),(0,o.kt)("h2",{id:"learning-outcomes"},"Learning Outcomes"),(0,o.kt)("p",null,"After reading this section, you will be able to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Design procedures using selection and iteration constructs to solve a programming task")),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"A complete programming language includes facilities to implement sequential constructs, in which one statement follows another and the statements are executed in order, and two other constructs, which represent modifications of sequential constructs.  Selection constructs represent different paths through the set of instructions.  Iteration constructs represent repetition of the same set of instructions until a specified condition has been met.  The three classes of constructs required to complete a programming language are illustrated in the figure below."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/constructs.png",alt:null})),(0,o.kt)("p",null,"Since programmers who maintain application software are typically not those who develop that software originally and the maintenance programmers may change throughout the lifetime of a software application, it is critical that the software is not only readable but also easy to upgrade and maintain.  The principles of structured programming, which were developed in the 1960s, provide important coding guidelines that respect this objective."),(0,o.kt)("p",null,"This chapter introduces the selection and iteration constructs supported by the C language and describes how to implement structured programming principles in coding iterations."),(0,o.kt)("h2",{id:"structured-programming"},"Structured Programming"),(0,o.kt)("p",null,"A structured program consists of sets of simple constructs, each of which has one entry point and one exit point.  Any programmer may replace one construct with an upgraded construct without affecting the other constructs in the program or introducing errors ","(",'"bugs"',")",". "),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/structured.png",alt:null})),(0,o.kt)("p",null,"The simplest example of a structured construct is a ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"sequence")),".  A sequence is either a simple statement or a code block.  A ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"code block"))," is a set of statements enclosed in a pair of curly braces to be executed sequentially. "),(0,o.kt)("h4",{id:"example-simple-statement"},"Example Simple Statement"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'// single statement (original)\nprintf("I like pizza\\n");\n')),(0,o.kt)("h4",{id:"example-code-block"},"Example Code Block"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'// code block (upgrade)\n{\n    printf("I like pizza\\n");\n    printf("I want more pizza\\n");\n}\n')),(0,o.kt)("p",null,"Unlike a single statement, a C code block does not require a terminating semi-colon of its own ","(","after the closing brace",")","."),(0,o.kt)("h2",{id:"preliminary-design"},"Preliminary Design"),(0,o.kt)("p",null,"During the design stage of a programming solution, it is helpful to outline the steps involved.  Well-established techniques include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"pseudo-coding"),(0,o.kt)("li",{parentName:"ul"},"flow charting")),(0,o.kt)("p",null,"Clear and concise pseudo-code or flow charts improve chances are that our coding will also be clear and concise. "),(0,o.kt)("h3",{id:"pseudo-code"},"Pseudo-Code"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"Pseudo-code"))," is a set of shorthand notes in a human ","(","non-programming",")"," language that itemizes the key steps in the sequence of instructions that produce a programming solution.  For example, the pseudo code for calculating the change in a vending machine might look something like"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Declare variables for quarters and nickels"),(0,o.kt)("li",{parentName:"ol"},"Calculate the number of quarters in the change"),(0,o.kt)("li",{parentName:"ol"},"Calculate the remainder to be returned in nickels"),(0,o.kt)("li",{parentName:"ol"},"Output the change in quarters and nickels")),(0,o.kt)("h3",{id:"flow-charts"},"Flow Charts"),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"flow chart"))," is a set of conventional symbols connected by arrows that illustrate the flow of control through a programming solution.  Popular sets of symbols for sequences, selections and iterations are shown below:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/flowChart.png",alt:null})),(0,o.kt)("p",null,"Usage of these sets with the C language is illustrated below."),(0,o.kt)("h2",{id:"selection-constructs"},"Selection Constructs"),(0,o.kt)("p",null,"The C language supports three selection constructs:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"optional path"),(0,o.kt)("li",{parentName:"ul"},"alternative paths"),(0,o.kt)("li",{parentName:"ul"},"conditional expression")),(0,o.kt)("p",null,"The flow charts for these three constructs are shown below:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/selection.png",alt:null})),(0,o.kt)("h3",{id:"optional-path"},"Optional Path"),(0,o.kt)("p",null,"The simplest selection construct executes a sequence only if a certain condition is satisfied; that is, only if the condition is true.  This optional selection takes the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"}," if (condition)\n    sequence\n")),(0,o.kt)("p",null,"Parentheses enclose the condition, which may be a relational expression or a logical expression.  The sequence may be a single statement or a code block. "),(0,o.kt)("h4",{id:"single-statement"},"Single Statement"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'if (likePizza == 1)\n    printf("I like pizza\\n");\n')),(0,o.kt)("h4",{id:"code-block-more-than-a-single-statement"},"Code Block ","(","more than a single statement",")"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'if (likePizza == 1) {\n     printf("I like pizza\\n");\n     printf("I want more pizza\\n"); \n}\n')),(0,o.kt)("p",null,"The program executes the sequence only if ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},(0,o.kt)("inlineCode",{parentName:"strong"},"likePizza")))," is equal to 1. Otherwise, the program bypasses the sequence altogether."),(0,o.kt)("h3",{id:"alternative-paths"},"Alternative Paths"),(0,o.kt)("p",null,"The C language supports two ways of describing alternative paths: an binary select construct and a multiple selection construct."),(0,o.kt)("h4",{id:"binary-selection"},"Binary Selection"),(0,o.kt)("p",null,"The binary selection construct executes one of a set of alternative sequences.  This construct takes the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"}," if (condition)\n    sequence\n else\n    sequence\n")),(0,o.kt)("p",null,"Parentheses enclose the condition, which may be a relational expression or a logical expression.  The sequences may be ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"single statements"))," or ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"code blocks")),".  The program executes the sequence following the if only if the condition is true.  The program executes the sequence following the ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"else"))," only if the condition is false. "),(0,o.kt)("h4",{id:"single-statement-1"},"Single Statement"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'if (likePizza == 1)\n    printf("I like pizza\\n");\nelse\n    printf("I hate pizza\\n");\n')),(0,o.kt)("h4",{id:"code-block-more-than-a-single-statement-1"},"Code Block ","(","more than a single statement",")"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'if (likePizza == 1) {\n    printf("I like pizza\\n");\n} \nelse {\n    printf("I hate pizza\\n");\n    printf("I don\'t want pizza\\n"); \n}\n')),(0,o.kt)("h4",{id:"multiple-selection"},"Multiple Selection"),(0,o.kt)("p",null,"For three alternative paths, we append an ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"if else"))," construct to the ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"else"))," keyword. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"}," if (condition)\n    sequence\n else if (condition)\n    sequence\n else\n    sequence\n")),(0,o.kt)("p",null,"If the first condition is true, the program skips the second and third sequences.  If the first condition is false, the program skips the first sequence and evaluates the second condition.  The program executes the second sequence only if the first condition is false and the second condition is true.  The program executes the third sequence and skips the first two only if both conditions are false."),(0,o.kt)("h4",{id:"compound-conditions"},"Compound Conditions"),(0,o.kt)("p",null,"The condition in a selection construct may be a ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"compound"))," condition.  A compound condition takes the form of a logical expression ","(","see the section on ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"Logical Expressions"))," in the chapter on ",(0,o.kt)("a",{parentName:"p",href:"/IPC144/docs/B-Computations/expressions"},"Expressions"),")",". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'if (age > 12 && age < 16)\n    printf("Student Fare - no id required\\n");\n else if (age > 15 && age < 20)\n    printf("Student Fare - id is required\\n"); \n else if (age < 13)\n    printf("Child ride for free!\\n");\n else if (age >= 65)\n    printf("Senior Fare - id is required\\n");\n else\n    printf("Adult Fare\\n");\n')),(0,o.kt)("h4",{id:"case-by-case"},"Case-by-Case"),(0,o.kt)("p",null,"The case-by-case selection construct compares a condition - simple or compound - against a set of constant values or constant expressions.  This construct takes the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"switch (condition) {\ncase constant:\n       sequence\n       break;\ncase constant:\n       sequence\n       break;\ndefault:\n       sequence\n}\n")),(0,o.kt)("p",null,"If the condition matches a constant, the program executes the sequence associated with the case for that constant.  The break; statement transfers control to the closing brace of the switch construct.  Braces around the statements between case labels are unnecessary. "),(0,o.kt)("p",null,"If a break statement is missing for a particular case, control flows through to the subsequent case and the program executes the sequence under that case as well. "),(0,o.kt)("p",null,"The program executes the sequence following default only if the condition does not match any of the case constants.  The ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"default"))," case is optional and this keyword may be omitted. "),(0,o.kt)("p",null,"For example, the following code snippet compares the value of choice to ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"'A'"))," or ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"'a'")),", ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"'B'"))," or ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"'b'")),", and ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"'C'"))," or ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"'c'"))," until successful.  If unsuccessful, the code snippet executes the statements under ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"default")),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"char choice;\ndouble cost;\n\nprintf(\"Enter your selection (a, b or c) ? \"); \nscanf(\"%c\", &choice);\n\nswitch (choice) {\ncase 'A' :\ncase 'a' :\n    cost = 1.50;\n    break;\ncase 'B' :\ncase 'b' :\n    cost = 1.10;\n    break;\ncase 'C' :\ncase 'c' :\n    cost = 0.75;\n    break;\ndefault:\n    choice = '?';\n    cost = 0.0;\n}\n\nprintf(\"%c costs %.2lf\\n\", choice, cost);\n")),(0,o.kt)("h3",{id:"conditional-expression"},"Conditional Expression"),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"conditional expression"))," selection construct ",(0,o.kt)("em",{parentName:"p"},"****_is shorthand for the "),(0,o.kt)("strong",{parentName:"p"},"alternative path"),"_ construct.  This ternary expression combines a condition and two sub-expressions using the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"? :"))," operators:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"}," condition ? operand : operand\n")),(0,o.kt)("p",null,"If the condition is true, the expression evaluates to the operand between ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"?"))," and ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},":")),".  If the condition is false, the expression evaluates to the operand following ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},":")),". "),(0,o.kt)("h4",{id:"example"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'int main()\n{\n    int minutes;\n    char s;\n    \n    printf("How many minutes left ? ");\n    scanf("%d", &minutes);\n    \n    s = minutes > 1 ? \'s\' : \' \';    // Conditional Expression\n    \n    printf("%d minute%c left\\n", minutes, s); \n    \n    return 0;\n}\n')),(0,o.kt)("p",null,"If the operands in a conditional expression are themselves expressions, the conditional expression only evaluates the operand identified by the condition. "),(0,o.kt)("h2",{id:"iteration-constructs"},"Iteration Constructs"),(0,o.kt)("p",null,"The C language supports three iteration constructs:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"while"),(0,o.kt)("li",{parentName:"ul"},"do while"),(0,o.kt)("li",{parentName:"ul"},"for")),(0,o.kt)("p",null,"Three instructions control the execution of an iteration: an initialization, a test condition, a change statement.  The test condition may be simple or compound.  The flow charts for the three constructs are shown below."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/iteration.png",alt:null})),(0,o.kt)("p",null,"If the change statement is missing or if the test condition is always satisfied, the iteration continues without terminating and the program can never terminate.  We say that such an iteration is an infinite loop. "),(0,o.kt)("h3",{id:"while"},"while"),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"while"))," construct executes its sequence as long as the test condition is true.  This construct takes the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"while (condition) {\n    sequence\n}\n")),(0,o.kt)("p",null,"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'slices = 4;\nwhile (slices > 0) {\n    slices--;\n    printf("Gulp! Slices left %d\\n", slices); \n}\n')),(0,o.kt)("p",null,"The above code produces the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"Gulp! Slices left 3\nGulp! Slices left 2\nGulp! Slices left 1\nGulp! Slices left 0\n")),(0,o.kt)("p",null,"If the condition is never true ","(","for example, if initially slice = 0",")",", this construct never executes the sequence."),(0,o.kt)("h3",{id:"do-while"},"do while"),(0,o.kt)("p",null,"he ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"do while"))," construct executes its sequence ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"at least once"))," and continues executing it as long as the test condition is true. This construct takes the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"do {\n    sequence\n} while (condition);\n")),(0,o.kt)("h4",{id:"example-1"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'slices = 4;\ndo {\n    slices--;\n    printf("Gulp! Slices left %d\\n", slices); \n}while (slices > 0);\n')),(0,o.kt)("p",null,"The above code produces the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"Gulp! Slices left 3\nGulp! Slices left 2\nGulp! Slices left 1\nGulp! Slices left 0\n")),(0,o.kt)("p",null,"If we change the initial value to slices = 12 and the test condition to slices ","<"," 5, this iteration displays once and stops because the test condition is false."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'slices = 12;\ndo {\n    slices--;\n    printf("Gulp! Slices left %d\\n", slices); \n} while (slices < 5);\n')),(0,o.kt)("p",null,"The above code produces the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"Gulp! Slices left 11\n")),(0,o.kt)("p",null,"This code contains a ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"semantic error")),": if the initial value was 5, the iteration would never end!"),(0,o.kt)("h3",{id:"for"},"for"),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"for"))," construct groups the initialization, test condition and change together, separating them with semi-colons.  This construct takes the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"for (initialization; condition; change) {\n    sequence\n}\n")),(0,o.kt)("h4",{id:"example-2"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'for (slices = 4; slices > 0; --slices) {\n    printf("Gulp! Slices left %d\\n", slices - 1); \n}\n')),(0,o.kt)("h2",{id:"flags"},"Flags"),(0,o.kt)("p",null,"Flagging is a method of coding iteration constructs within the single-entry single-exit rule of structured programming.  Consider the flow-chart on the left side in the figure below.  This design contains a path that crosses another path. "),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/flags.png",alt:null})),(0,o.kt)("p",null,"Flags are variables that determine whether an iteration continues or stops.  A flag is either true or false.  Flags helps ensure that no paths cross one another.  By introducing a flag, we avoid the jump and multiple exit, obtain a flow chart where no path crosses any other and hence an improved design."),(0,o.kt)("h4",{id:"example-3"},"Example"),(0,o.kt)("p",null,"The following code snippet uses a flag to terminate the iteration prematurely."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'int done = 0;  // flag\nint total = 0; // accumulator\nfor (i = 0; i < 10 && done == 0; i++) {\n    printf("Enter integer (0 to stop) "); \n    scanf("%d", &value);\n    if (value == 0) {\n        done = 1;\n    }\n    else {\n        total += value;\n    }\n}\nprintf("Total = %d\\n", total); \n')),(0,o.kt)("p",null,"Example execution of the code above:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"Enter integer (0 to stop) 45 \nEnter integer (0 to stop) 32\nEnter integer (0 to stop) 3\nEnter integer (0 to stop) -6\nEnter integer (0 to stop) 0\nTotal = 74\n")),(0,o.kt)("p",null,"The test condition is compound due to the evaluation of the flag.  If ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"done == 1")),", the iteration stops. "),(0,o.kt)("h3",{id:"avoid-jumps-optional"},"Avoid Jumps ","(","Optional",")"),(0,o.kt)("p",null,"Designing a program with jumps or intersecting paths makes it more difficult to read.  We refer to program code that contains paths that cross one another as spaghetti code.  The roots of spaghetti coding lie in assembly languages ","(","second-generation languages",")",".  Assembly languages include jump instructions.  Jump instructions migrated to high-level languages as assembly language programmers started coding in higher-level languages.  Spaghetti code was a serious problem in the 1960's.  To improve readability, many programmers started to advocate complete avoidance of jump statements and introduced ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"flags"))," as the good-design alternative. "),(0,o.kt)("h2",{id:"nested-constructs"},"Nested Constructs"),(0,o.kt)("p",null,"Enclosing one logic construct within another is called ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"nesting")),".   "),(0,o.kt)("h3",{id:"nested-selections"},"Nested Selections"),(0,o.kt)("p",null,"A selection within another selection is called a ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"nested selection")),"."),(0,o.kt)("h4",{id:"example-4"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'if (grade < 50) {\n    if (sup == 1)\n        printf("Sup\\n");\n    else\n        printf("Failed\\n"); \n}\nelse\n    printf("Pass\\n);\n')),(0,o.kt)("h3",{id:"dangling-else"},"Dangling Else"),(0,o.kt)("p",null,"An ambiguity arises in a ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"nested if else"))," construct that contains an optional sequence ","(",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"if")),")",".  Consider the following code snippet:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'if (grade < 50) {\n    if (sup == 1)\n        printf("Sup\\n");\n}\nelse\n    printf("Pass\\n);\n')),(0,o.kt)("p",null,"It is unclear to which if the else belongs if we remove the first pair of braces:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'// does else belong to FIRST if?\nif (grade < 50)\n    if (sup == 1)\n        printf("Sup\\n");\nelse\n    printf("Pass\\n); \n')),(0,o.kt)("p",null,"... OR ..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'// does else belong to SECOND if?\nif (grade < 50)\n    if (sup == 1)\n        printf("Sup\\n");\n    else\n        printf("Pass\\n);\n')),(0,o.kt)("p",null,"The C language always attaches the dangling else to the innermost if. "),(0,o.kt)("p",null,"To associate an else with the next innermost selection, we retain the braces that wrap the innermost selection. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'if (grade < 50) b{\n    if (sup == 1)\n        printf("Sup\\n");\n} \nelse {\n    printf("Pass\\n); \n}\n')),(0,o.kt)("h3",{id:"nested-iterations"},"Nested Iterations"),(0,o.kt)("p",null,"An iteration within another iteration is called a ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"nested iteration")),"."),(0,o.kt)("p",null,"The program below includes a nested iteration:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'// Rows and Columns\n// row_columns.c\n\n#include <stdio.h>\n\nint main(void)\n{\n    int i, j;\n    for (i = 0; i < 5; i++) {\n        for (j = 0; j < 5; j++) {\n            printf("%d,%d  ", i, j); \n        }\n        printf("\\n");\n    }\n    \n    return 0;\n}\n')),(0,o.kt)("p",null,"The output of the code above:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"0,0  0,1  0,2  0,3  0,4\n1,0  1,1  1,2  1,3  1,4\n2,0  2,1  2,2  2,3  2,4\n3,0  3,1  3,2  3,3  3,4\n4,0  4,1  4,2  4,3  4,4 \n")))}m.isMDXComponent=!0}}]);